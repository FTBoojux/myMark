# 缓存

### 1、Redis数据类型

- 1、String：字符串类型，可以是普通字符串、数字或二进制数据。

- 2、Hash：哈希类型，可以存储多个键值对，类似于一个小的散列表。

- 3、List：列表类型，可以存储有序的字符串列表，可以在头部和尾部添加、删除、更新元素。

- 4、Set：集合类型，可以存储多个唯一的元素，可以进行集合运算，如并集、交集、差集等。

- 5、Sorted Set：有序集合类型，可以存储多个唯一的元素，并按照指定的排序方式进行排序，常用于排行榜等场景。

- 6、Bitmap：位图类型，可以将一个大整数作为一个位数组来处理，可用于数据统计、用户在线状态判断等场景。

- 7、HyperLogLog：基数统计类型，可以用来估计一个集合中的元素数量。

### 2、缓存穿透

缓存穿透是指一个查询非常耗时，而且在缓存中不存在的数据，导致大量的查询请求直接穿透到数据库，给数据库带来巨大的压力，甚至可能导致数据库宕机。

缓存穿透通常是由于缓存和数据库中的数据不一致，或者是缓存和数据库中的数据没有同步导致的。当用户请求一个不存在的数据时，缓存会发现缓存中没有这个数据，然后会将查询请求发送给数据库。如果查询的数据非常耗时，那么就会导致大量的查询请求直接穿透到数据库，给数据库带来极大的压力。

为了避免缓存穿透问题，可以采取以下几种措施：

1. 使用布隆过滤器（Bloom Filter）过滤掉一部分不存在的请求，可以在缓存层快速过滤掉查询条件不合法的请求，减轻数据库的压力。
2. 使用缓存中不存在的值进行缓存填充，可以将这些不存在的值缓存到缓存中，但是对应的值为空。这样可以防止用户频繁查询不存在的值，减轻数据库的压力。
3. 设置缓存过期时间，可以避免因为缓存一直存在而导致的数据不一致问题。
4. 在缓存和数据库之间增加一层数据同步机制，可以在数据发生变化时自动同步缓存和数据库中的数据，保证数据的一致性。

### 3、缓存击穿

缓存击穿是指缓存中不存在但数据库中存在的数据，被大量请求同时查询，导致大量请求直接穿透到数据库，给数据库带来极大的压力。

与缓存穿透不同，缓存击穿发生的查询请求对应的数据在数据库中是存在的，只是因为缓存过期或者缓存被删除导致了缓存中没有这个数据，导致大量请求直接访问数据库。

为了避免缓存击穿问题，可以采取以下几种措施：

1. 设置热点数据永不过期，可以将热点数据设置为永久不过期，保证这些数据始终存在于缓存中。
2. 加锁控制，可以在缓存中设置相应的锁机制，当一个请求需要查询缓存中不存在的数据时，首先检查缓存中是否已经有其他线程正在加载该数据，如果有则等待，直到其他线程加载完成。
3. 异步更新缓存，可以在缓存中异步更新缓存，当缓存过期时，后台线程可以负责加载数据到缓存中，避免请求直接访问数据库。

对于第二点：

在缓存中设置相应的锁机制，可以避免缓存击穿问题。当一个请求需要查询缓存中不存在的数据时，可以在缓存中设置一个与该数据对应的锁，当其他请求需要查询同样的数据时，首先检查缓存中是否已经有其他线程正在加载该数据，如果有则等待，直到其他线程加载完成。

在 Java 中可以使用 ReentrantLock 实现锁机制，示例代码如下：

```java
private Map<String, Object> cache = new HashMap<>();
private Map<String, ReentrantLock> locks = new HashMap<>();

public Object getData(String key) {
    Object result = cache.get(key);
    if (result == null) {
        ReentrantLock lock = null;
        synchronized (locks) {
            lock = locks.get(key);
            if (lock == null) {
                lock = new ReentrantLock();
                locks.put(key, lock);
            }
        }
        lock.lock();
        try {
            result = cache.get(key);
            if (result == null) {
                // 从数据库中获取数据并写入缓存
                result = fetchDataFromDB(key);
                cache.put(key, result);
            }
        } finally {
            lock.unlock();
        }
    }
    return result;
}
```



### 4、缓存雪崩

缓存雪崩是指在缓存中的大量数据同时失效或者缓存服务宕机，导致大量请求直接访问数据库，给数据库带来极大的压力。

与缓存穿透和缓存击穿不同，缓存雪崩发生时，缓存中大量的数据同时失效，导致大量的请求直接访问数据库，从而使数据库的压力急剧上升，可能会导致数据库宕机。

为了避免缓存雪崩问题，可以采取以下几种措施：

1. 设置缓存失效时间随机化，可以将缓存失效时间设置成一个随机的时间，避免大量的缓存同时失效导致缓存雪崩。
2. 实现缓存的自动刷新，可以在缓存数据过期之前就开始进行自动刷新，从而保证缓存中的数据一直是有效的。
3. 使用集群缓存，可以将缓存服务分布在多台服务器上，避免单点故障。
4. 数据预热，可以在系统启动时预先加载缓存中的数据，避免大量请求同时访问数据库。

总之，缓存雪崩是一个常见的问题，需要在设计缓存方案时考虑到，采取相应的措施来避免这个问题的发生。

### 5、Redis淘汰策略

Redis提供了几种不同的缓存淘汰策略，允许用户根据他们的特定需求选择最适合的策略。以下是Redis的一些缓存淘汰策略：

- 1. **无淘汰（noeviction）：** 当内存不足以容纳新写入数据时，新的写操作会报错。这是默认策略。

- 2. **最少最近使用（Least Recently Used，LRU）：** 尝试淘汰最少使用的键，使得常用的键能够常驻内存。

- 3. **最近最少使用（Least Frequently Used，LFU）：** 尝试淘汰最近最少使用的键。

- 4. **volatile-lru** 和 **volatile-lfu**： 适用于设置了过期时间的键，根据LRU算法或者LFU算法来淘汰。

- 5. **volatile-random**：在设置了过期时间的键中，随机选择一些键进行淘汰。

- 6. **volatile-ttl**：在设置了过期时间的键中，有更早过期时间的优先淘汰。

- 7. **allkeys-lru** 和 **allkeys-lfu**：从数据集（设置了过期时间的键和没有设置过期时间的键）中选择键，然后根据LRU或者LFU算法淘汰。

- 8. **allkeys-random**：从数据集中随机选择一些键进行淘汰。

用户可以根据他们的具体需求和系统的特性，选择最合适的淘汰策略。