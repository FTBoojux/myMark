# JVM

### 1、类加载流程

详： https://pdai.tech/md/java/jvm/java-jvm-classload.html

- 加载：查找和加载类的二进制数据
- 连接：
  - 验证：确保被加载的类的正确性
  - 准备：为类的静态变量分配内存，并将其初始化为默认值
  - 解析：把类中的符号引用转换为直接引用
- 初始化
- 使用
- 卸载

### 2、常用的垃圾回收算法

- 标记清除
- 标记整理
- 标记复制
- 分代回收

### 3、JVM内存结构

- 程序计数器
  - 记录各个线程当前指令的位置
  - 线程私有
- 虚拟机栈
  - 线程私有
  - 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- 本地方法栈
  - 线程私有
  - 与Java外的环境（如操作系统）交互
  - HotSpot中与虚拟机栈合二为一
- 堆
  - 线程共享
  - 存放对象示例
- 方法区
  - 线程共享
  - HotSpot中的永久代/元空间

### 4、双亲委派机制

双亲委派机制（Parent Delegation Model）是Java类加载机制中的一种重要机制。当类加载器需要加载一个类时，它首先将这个任务委托给父类加载器，如果父类加载器还有父类加载器，则一直向上委托，直到委托到最顶层的启动类加载器。如果父类加载器无法加载这个类，子类加载器才会尝试加载这个类。

这种机制的作用是保证Java核心库的类不会被自定义类库中的类所替代。例如，在加载`java.lang.Object`这个类时，应用程序的类加载器会先将该任务委派给父类加载器，也就是扩展类加载器。如果扩展类加载器无法加载该类，再将委派任务传递给父类加载器，也就是启动类加载器。如果启动类加载器还是无法加载该类，就会抛出`ClassNotFoundException`异常。这样可以确保Java核心库的类不会被自定义类库中的同名类所替代。

通过双亲委派机制，可以避免重复加载同一个类，提高了类加载的效率，并且能够确保Java核心库的安全性，防止恶意代码篡改Java核心库的类。

### 5、JVM垃圾回收流程

1.标记阶段（Marking）：从根对象开始遍历，将所有被根对象引用的对象都打上标记。

2.清除阶段（Sweeping）：将没有标记的对象进行回收。

3.压缩阶段（Compacting）：将被标记的对象压缩到一起，空出的空间用来存储新的对象。

以上是传统的垃圾回收算法流程，还有一些其他的垃圾回收算法，例如分代回收算法，具体的实现和流程会有所不同。

分代回收算法根据对象的存活周期分为年轻代和老年代，年轻代中的对象大多都是朝生夕死的，因此采用复制算法进行回收，老年代中的对象则是存活时间较长的，采用标记-清除或标记-整理算法进行回收。

### 6、JVM参数

- -Xmn：设置年轻代大小

### 7、Java中调用System.gc()一定能触发gc吗

不一定。虽然System.gc()方法会建议JVM进行垃圾回收，但JVM是否真正执行垃圾回收，还是要看JVM的具体实现。JVM一般会自动管理内存，包括垃圾回收，开发人员不需要手动调用System.gc()方法。如果JVM在需要回收内存时决定不执行垃圾回收，那么调用System.gc()方法也不会起作用。