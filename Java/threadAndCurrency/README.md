# 多线程与高并发

### 1、volatile关键字的作用

- 1、防止JVM优化自动重排序（参考单例类分配内存-初始化-赋值 变 分配 - 赋值 -初始化）
- 2、线程间变量可见性
- 3、保证单次读写的原子性

### 2、AQS基本队列的原理

AQS（AbstractQueuedSynchronizer）是Java中的一个并发工具类，它提供了一个基本的队列机制，用于实现锁、信号量、倒计时器等同步工具。

AQS的基本队列是指一种先进先出的双向链表，用于存储等待获取锁的线程。这个队列由AQS内部维护，主要包括两个指针：head和tail。head指向队列中的第一个节点，tail指向队列中的最后一个节点。当一个线程获取锁失败时，它会被加入到这个队列的末尾，等待其他线程释放锁后再次尝试获取锁。

AQS的基本队列的操作包括入队（enqueuing）和出队（dequeuing）。当一个线程需要获取锁时，它会尝试入队；当一个线程释放锁时，它会尝试出队。由于AQS的基本队列是双向链表，因此入队和出队的操作非常高效，时间复杂度为O(1)。

AQS的基本队列是实现锁、信号量、倒计时器等同步工具的核心，这些同步工具都是基于AQS的基本队列进行实现的。在Java的并发编程中，AQS的基本队列是一个非常重要的概念，理解它可以帮助我们更好地理解Java中的并发工具和同步机制。

### 3、CAS

CAS是Compare And Swap（比较并交换）的缩写，是一种用于实现多线程同步的原子操作。

CAS操作包括三个参数：内存地址V、期望值A和新值B。CAS会先读取内存地址V中的值，如果该值等于期望值A，则将内存地址V中的值更新为新值B；否则不做任何操作。CAS操作是原子性的，即多个线程同时进行CAS操作时，只有一个线程能成功执行操作，其它线程需要重新尝试。

CAS的主要优点是比较高的并发性和非阻塞性，不需要使用锁来实现同步，因此避免了锁的开销和死锁等问题。它在一些多线程并发编程的场景中非常有用，例如计数器、队列等数据结构的实现。

在Java中，CAS操作是通过java.util.concurrent包中的AtomicInteger等原子类实现的，这些类提供了一些方法来实现CAS操作，如compareAndSet()等。通过使用原子类和CAS操作，Java提供了一种非常高效的多线程同步机制，避免了传统锁机制的开销和问题。

### 4、ABA问题

ABA问题是一种在多线程编程中可能出现的问题，它指的是在一个线程修改某个共享变量时，其他线程可能会对该变量进行干扰，导致出现意外的结果。

具体来说，ABA问题发生在以下场景中：假设线程A读取共享变量的值为A，接着线程B将共享变量的值修改为B，然后又将共享变量的值修改为A，此时线程A再次读取共享变量的值也是A，因此线程A无法感知到变量的中间状态（即从A变成B再变回A），可能会对后续的操作造成错误的判断和结果。

解决ABA问题的常见方法是通过添加版本号或时间戳等机制来对共享变量的状态进行跟踪，这样即使共享变量的值从A变成B再变回A，版本号或时间戳也会随之更新，从而避免出现ABA问题。另外，Java中的一些同步工具（如CAS和AtomicStampedReference）也提供了一些原子操作，可以用于解决ABA问题。

### 5、ConcurrenthashMap如何保证线程安全？

1. 分段锁：将整个数据结构分成多个segment（默认为16），每个segment维护一个独立的哈希表，每个segment内部实现了自己的锁机制，不同segment之间互不干扰，不同线程访问不同segment的时候可以并发进行，从而提高了并发度；
2. volatile关键字：在Java内存模型中，通过volatile关键字可以保证可见性和有序性，因此ConcurrentHashMap内部使用了volatile关键字来保证数据的可见性和有序性，防止线程之间发生数据竞争；
3. CAS（Compare-And-Swap）操作：ConcurrentHashMap内部使用了CAS操作来保证数据的一致性。在多线程并发情况下，当多个线程同时修改同一个数据时，只有一个线程能够成功修改，其他线程需要不断重试直到成功，从而保证数据的一致性。

通过这些并发控制技术，**`ConcurrentHashMap`**能够高效地支持多线程并发访问，而不需要像**`Hashtable`**一样使用全局锁来保证线程安全，从而在高并发场景下具有更好的性能表现。

### 6、使用**CountDownLatch时有任务失败了怎么办**

?

如果在 **`CountDownLatch`** 中某个任务失败了，即某个任务的线程抛出了异常，可以考虑将该异常保存下来，并在其他线程中检查它。一种实现方式是使用一个 **`AtomicReference`\**对象保存异常，每个线程检查该对象是否为\**`null`**，如果不为 **`null`**，则说明其他线程中有一个任务失败了，需要将异常重新抛出。